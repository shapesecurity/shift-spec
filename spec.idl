/**
 * Copyright 2014 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
  INFO: This specification is currently divided into the following sections:
  * supporting types
  * node classes
  * bindings
  * classes
  * modules
  * functions
  * object expressions
  * literals
  * other expressions
  * other statements
  * directives
  * other nodes
*/


// supporting types

enum Type {
  "ArrayBinding",
  "ArrayExpression",
  "ArrowExpression",
  "AssignmentExpression",
  "BinaryExpression",
  "BindingIdentifier",
  "BindingPropertyIdentifier",
  "BindingPropertyProperty",
  "BindingWithDefault",
  "Block",
  "BlockStatement",
  "BreakStatement",
  "CallExpression",
  "CatchClause",
  "ClassDeclaration",
  "ClassElement",
  "ClassExpression",
  "ComputedMemberExpression",
  "ComputedPropertyName",
  "ConditionalExpression",
  "ContinueStatement",
  "DataProperty",
  "DebuggerStatement",
  "Directive",
  "DoWhileStatement",
  "EmptyStatement",
  "Export",
  "ExportAllFrom",
  "ExportDefault",
  "ExportFrom",
  "ExportSpecifier",
  "ExpressionStatement",
  "ForInStatement",
  "ForOfStatement",
  "ForStatement",
  "FunctionBody",
  "FunctionDeclaration",
  "FunctionExpression",
  "Getter",
  "IdentifierExpression",
  "IfStatement",
  "Import",
  "ImportNamespace",
  "ImportSpecifier",
  "LabeledStatement",
  "LiteralBooleanExpression",
  "LiteralInfinityExpression",
  "LiteralNullExpression",
  "LiteralNumericExpression",
  "LiteralRegExpExpression",
  "LiteralStringExpression",
  "Method",
  "Module",
  "NewExpression",
  "NewTargetExpression",
  "ObjectBinding",
  "ObjectExpression",
  "ParameterList",
  "PostfixExpression",
  "PrefixExpression",
  "ReturnStatement",
  "Script",
  "Setter",
  "ShorthandProperty",
  "SpreadElement",
  "StaticMemberExpression",
  "StaticPropertyName",
  "Super",
  "SwitchCase",
  "SwitchDefault",
  "SwitchStatement",
  "SwitchStatementWithDefault",
  "TemplateElement",
  "TemplateExpression",
  "ThisExpression",
  "ThrowStatement",
  "TryCatchStatement",
  "TryFinallyStatement",
  "VariableDeclaration",
  "VariableDeclarationStatement",
  "VariableDeclarator",
  "WhileStatement",
  "WithStatement",
  "YieldExpression",
  "YieldGeneratorExpression",
};

typedef (SpreadElement or Expression)[] Arguments;
typedef DOMString string;
typedef string Identifier;
typedef string IdentifierName;
typedef string Label;

enum VariableDeclarationKind { "var", "let", "const" };

enum AssignmentOperator {
  "=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&="
};
enum BinaryOperator {
  "==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<",
  ">>", ">>>", "+", "-", "*", "/", "%", ",", "||", "&&", "|", "^", "&"
};
enum PrefixOperator { "+", "-", "!", "~", "typeof", "void", "delete", "++", "--" };
enum PostfixOperator { "++", "--" };

interface SourceLocation {
  attribute unsigned long line;
  attribute unsigned long column;
  attribute unsigned long offset;
};

interface SourceSpan {
  attribute string? source;
  attribute SourceLocation start;
  attribute SourceLocation end;
};


// node classes

interface Node {
  attribute SourceSpan? loc;
};

interface Statement : Node { };
interface IterationStatement : Node {
  attribute Statement body;
};

interface Expression : Node { };
interface UnaryExpression : Expression {
  attribute Expression operand;
};
interface MemberExpression : Expression {
  attribute (Expression or Super) _object;
};

interface PropertyName : Node { };

interface ObjectProperty : Node { };
interface NamedObjectProperty : ObjectProperty {
  attribute PropertyName name;
};
interface MethodDefinition : NamedObjectProperty {
  attribute FunctionBody body;
};

interface ImportDeclaration : Node {
  attribute string moduleSpecifier;
};
interface ExportDeclaration : Node { };


// bindings

typedef (ObjectBinding or ArrayBinding or BindingIdentifier or MemberExpression) Binding;

interface BindingWithDefault : Node {
  const Type type = "BindingWithDefault";
  attribute Binding binding;
  attribute Expression init;
};

interface BindingIdentifier : Node {
  const Type type = "BindingIdentifier";
  attribute Identifier name;
};

interface ArrayBinding : Node {
  const Type type = "ArrayBinding";
  attribute (Binding or BindingWithDefault)?[] elements;
  attribute Binding? restElement;
};

interface ObjectBinding : Node {
  const Type type = "ObjectBinding";
  attribute BindingProperty[] properties;
};

interface BindingProperty : Node {
  const Type type = "BindingProperty";
};

interface BindingPropertyIdentifier : BindingProperty {
  const Type type = "BindingPropertyIdentifier";
  attribute BindingIdentifier binding;
  attribute Expression? init;
};

interface BindingPropertyProperty : BindingProperty {
  const Type type = "BindingPropertyProperty";
  attribute PropertyName name;
  attribute (Binding or BindingWithDefault) binding;
};


// classes

interface Class {
  attribute Expression? super;
  attribute ClassElement[] elements;
};

interface ClassExpression : Expression {
  const Type type = "ClassExpression";
  attribute BindingIdentifier? name;
};
ClassExpression implements Class;

interface ClassDeclaration : Statement {
  const Type type = "ClassDeclaration";
  attribute BindingIdentifier name;
};
ClassDeclaration implements Class;

interface ClassElement : Node {
  const Type type = "ClassElement";
  attribute boolean isStatic;
  attribute MethodDefinition method;
};


// modules

interface Module : Node {
  const Type type = "Module";
  attribute (ImportDeclaration or ExportDeclaration or Statement)[] items;
};

interface Import : ImportDeclaration {
  const Type type = "Import";
  attribute BindingIdentifier? defaultBinding;
  attribute ImportSpecifier[] namedImports;
};

interface ImportNamespace : ImportDeclaration {
  const Type type = "ImportNamespace";
  attribute BindingIdentifier? defaultBinding;
  attribute BindingIdentifier namespaceBinding;
};

interface ImportSpecifier : Node {
  const Type type = "ImportSpecifier";
  attribute IdentifierName? name;
  attribute BindingIdentifier binding;
};

interface ExportAllFrom : ExportDeclaration {
  const Type type = "ExportAllFrom";
  attribute string moduleSpecifier;
};

interface ExportFrom : ExportDeclaration {
  const Type type = "ExportFrom";
  attribute ExportSpecifier[] namedExports;
  attribute string? moduleSpecifier;
};

interface Export : ExportDeclaration {
  const Type type = "Export";
  attribute (FunctionDeclaration or ClassDeclaration or VariableDeclaration) declaration;
};

interface ExportDefault : ExportDeclaration {
  const Type type = "ExportDefault";
  attribute (FunctionDeclaration or ClassDeclaration or Expression) body;
};

interface ExportSpecifier : Node {
  const Type type = "ExportSpecifier";
  attribute IdentifierName? name;
  attribute IdentifierName exportedName;
};


// functions

interface Function {
  attribute (Binding or BindingWithDefault)[] parameters;
  attribute BindingIdentifier? restParameter;
};

interface ArrowExpression : Expression {
  const Type type = "ArrowExpression";
  attribute (FunctionBody or Expression) body;
};
ArrowExpression implements Function;

interface FunctionBody : Node {
  const Type type = "FunctionBody";
  attribute Directive[] directives;
  attribute Statement[] statements;
};

interface FunctionDeclaration : Statement {
  const Type type = "FunctionDeclaration";
  attribute boolean isGenerator;
  attribute BindingIdentifier name;
  attribute FunctionBody body;
};
FunctionDeclaration implements Function;

interface FunctionExpression : Expression {
  const Type type = "FunctionExpression";
  attribute boolean isGenerator;
  attribute BindingIdentifier? name;
  attribute FunctionBody body;
};
FunctionExpression implements Function;


// object expressions

interface ObjectExpression : Expression {
  const Type type = "ObjectExpression";
  attribute ObjectProperty[] properties;
};

interface Method : MethodDefinition {
  const Type type = "Method";
  attribute boolean isGenerator;
};
Method implements Function;

interface Getter : MethodDefinition {
  const Type type = "Getter";
};

interface Setter : MethodDefinition {
  const Type type = "Setter";
  attribute Binding parameter;
};

interface DataProperty : NamedObjectProperty {
  const Type type = "DataProperty";
  attribute Expression expression;
};

interface ShorthandProperty : ObjectProperty {
  const Type type = "ShorthandProperty";
  attribute Identifier name;
};

interface ComputedPropertyName : PropertyName {
  const Type type = "ComputedPropertyName";
  attribute Expression expression;
};

interface StaticPropertyName : PropertyName {
  const Type type = "StaticPropertyName";
  attribute string value;
};


// literals

interface LiteralBooleanExpression : Expression {
  const Type type = "LiteralBooleanExpression";
  attribute boolean value;
};

interface LiteralInfinityExpression : Expression {
  const Type type = "LiteralInfinityExpression";
};

interface LiteralNullExpression : Expression {
  const Type type = "LiteralNullExpression";
};

interface LiteralNumericExpression : Expression {
  const Type type = "LiteralNumericExpression";
  attribute double value;
};

interface LiteralRegExpExpression : Expression {
  const Type type = "LiteralRegExpExpression";
  attribute string pattern;
  attribute string flags;
};

interface LiteralStringExpression : Expression {
  const Type type = "LiteralStringExpression";
  attribute string value;
};


// other expressions

interface ArrayExpression : Expression {
  const Type type = "ArrayExpression";
  attribute (SpreadElement or Expression)?[] elements;
};

interface AssignmentExpression : Expression {
  const Type type = "AssignmentExpression";
  attribute AssignmentOperator operator;
  attribute Binding binding;
  attribute Expression expression;
};

interface BinaryExpression : Expression {
  const Type type = "BinaryExpression";
  attribute BinaryOperator operator;
  attribute Expression left;
  attribute Expression right;
};

interface CallExpression : Expression {
  const Type type = "CallExpression";
  attribute (Expression or Super) callee;
  attribute Arguments arguments;
};

interface ComputedMemberExpression : MemberExpression {
  const Type type = "ComputedMemberExpression";
  attribute Expression expression;
};

interface ConditionalExpression : Expression {
  const Type type = "ConditionalExpression";
  attribute Expression test;
  attribute Expression consequent;
  attribute Expression alternate;
};

interface IdentifierExpression : Expression {
  const Type type = "IdentifierExpression";
  attribute Identifier name;
};

interface NewExpression : Expression {
  const Type type = "NewExpression";
  attribute Expression callee;
  attribute Arguments arguments;
};

interface NewTargetExpression : Expression {
  const Type type = "NewTargetExpression";
};

interface PostfixExpression : UnaryExpression {
  const Type type = "PostfixExpression";
  attribute PostfixOperator operator;
};

interface PrefixExpression : UnaryExpression {
  const Type type = "PrefixExpression";
  attribute PrefixOperator operator;
};

interface StaticMemberExpression : MemberExpression {
  const Type type = "StaticMemberExpression";
  attribute IdentifierName property;
};

interface TemplateExpression : Expression {
  const Type type = "TemplateExpression";
  attribute Expression? tag;
  attribute (Expression or TemplateElement)[] elements;
};

interface ThisExpression : Expression {
  const Type type = "ThisExpression";
};

interface YieldExpression : Expression {
  const Type type = "YieldExpression";
  attribute Expression? expression;
};

interface YieldGeneratorExpression : Expression {
  const Type type = "YieldGeneratorExpression";
  attribute Expression expression;
};


// other statements

interface BlockStatement : Statement {
  const Type type = "BlockStatement";
  attribute Block block;
};

interface BreakStatement : Statement {
  const Type type = "BreakStatement";
  attribute Label? label;
};

interface ContinueStatement : Statement {
  const Type type = "ContinueStatement";
  attribute Label? label;
};

interface DebuggerStatement : Statement {
  const Type type = "DebuggerStatement";
};

interface DoWhileStatement : IterationStatement {
  const Type type = "DoWhileStatement";
  attribute Expression test;
};

interface EmptyStatement : Statement {
  const Type type = "EmptyStatement";
};

interface ExpressionStatement : Statement {
  const Type type = "ExpressionStatement";
  attribute Expression expression;
};

interface ForInStatement : IterationStatement {
  const Type type = "ForInStatement";
  attribute (VariableDeclaration or Binding) left;
  attribute Expression right;
};

interface ForOfStatement : IterationStatement {
  const Type type = "ForOfStatement";
  attribute (VariableDeclaration or Binding) left;
  attribute Expression right;
};

interface ForStatement : IterationStatement {
  const Type type = "ForStatement";
  attribute (VariableDeclaration or Expression)? init;
  attribute Expression? test;
  attribute Expression? update;
};

interface IfStatement : Statement {
  const Type type = "IfStatement";
  attribute Expression test;
  attribute Statement consequent;
  attribute Statement? alternate;
};

interface LabeledStatement : Statement {
  const Type type = "LabeledStatement";
  attribute Label label;
  attribute Statement body;
};

interface ReturnStatement : Statement {
  const Type type = "ReturnStatement";
  attribute Expression? expression;
};

interface SwitchStatement : Statement {
  const Type type = "SwitchStatement";
  attribute Expression discriminant;
  attribute SwitchCase[] cases;
};

interface SwitchStatementWithDefault : Statement {
  const Type type = "SwitchStatementWithDefault";
  attribute Expression discriminant;
  attribute SwitchCase[] preDefaultCases;
  attribute SwitchDefault defaultCase;
  attribute SwitchCase[] postDefaultCases;
};

interface ThrowStatement : Statement {
  const Type type = "ThrowStatement";
  attribute Expression expression;
};

interface TryCatchStatement : Statement {
  const Type type = "TryCatchStatement";
  attribute Block body;
  attribute CatchClause catchClause;
};

interface TryFinallyStatement : Statement {
  const Type type = "TryFinallyStatement";
  attribute Block body;
  attribute CatchClause? catchClause;
  attribute Block finalizer;
};

interface VariableDeclarationStatement : Statement {
  const Type type = "VariableDeclarationStatement";
  attribute VariableDeclaration declaration;
};

interface WhileStatement : IterationStatement {
  const Type type = "WhileStatement";
  attribute Expression test;
};

interface WithStatement : Statement {
  const Type type = "WithStatement";
  attribute Expression _object;
  attribute Statement body;
};


// other nodes

interface Block : Node {
  const Type type = "Block";
  attribute Statement[] statements;
};

interface CatchClause : Node {
  const Type type = "CatchClause";
  attribute Binding binding;
  attribute Block body;
};

interface Directive : Node {
  const Type type = "Directive";
  attribute string rawValue;
};

interface Script : Node {
  const Type type = "Script";
  attribute FunctionBody body;
};

interface SpreadElement : Node {
  const Type type = "SpreadElement";
  attribute Expression expression;
};

interface Super : Node {
  const Type type = "Super";
};

interface SwitchCase : Node {
  const Type type = "SwitchCase";
  attribute Expression test;
  attribute Statement[] consequent;
};

interface SwitchDefault : Node {
  const Type type = "SwitchDefault";
  attribute Statement[] consequent;
};

interface TemplateElement : Node {
  const Type type = "TemplateElement";
  attribute string rawValue;
};

interface VariableDeclaration : Node {
  const Type type = "VariableDeclaration";
  attribute VariableDeclarationKind kind;
  [NonEmpty] attribute VariableDeclarator[] declarators;
};

interface VariableDeclarator : Node {
  const Type type = "VariableDeclarator";
  attribute Binding binding;
  attribute Expression? init;
};
