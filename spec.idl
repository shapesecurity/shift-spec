/**
 * Copyright 2014 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
  INFO: This specification is currently divided into the following sections:
  * supporting types
  * node classes
  * bindings
  * classes
  * modules
  * functions
  * object expressions
  * literals
  * other expressions
  * other statements
  * directives
  * other nodes
*/


// supporting types


typedef (SpreadElement or Expression)[] Arguments;
typedef DOMString string;
typedef string Identifier;
typedef string IdentifierName;
typedef string Label;

enum VariableDeclarationKind { "var", "let", "const" };

enum CompoundAssignmentOperator {
  "+=", "-=", "*=", "/=", "%=", "**=", "<<=", ">>=", ">>>=", "|=", "^=", "&="
};
enum BinaryOperator {
  "==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<",
  ">>", ">>>", "+", "-", "*", "/", "%", "**", ",", "||", "&&", "|", "^", "&"
};
enum UnaryOperator { "+", "-", "!", "~", "typeof", "void", "delete" };
enum UpdateOperator { "++", "--" };

interface Function { // `FunctionExpression`, `FunctionDeclaration`, `GeneratorExpression`, `GeneratorDeclaration`, `AsyncFunctionExpression`, `AsyncFunctionDeclaration`
  attribute boolean isAsync; // true for `AsyncFunctionExpression` and `AsyncFunctionDeclaration`, false otherwise
  attribute boolean isGenerator; // true for `GeneratorExpression` and `GeneratorDeclaration`, false otherwise
  attribute FormalParameters params;
  attribute FunctionBody body;
};

// node classes

interface Node {
  [TypeIndicator] readonly attribute Type type;
};

interface Program : Node { }; // `Script`, `Module`

interface Statement : Node { };
interface IterationStatement : Statement {
  attribute Statement body;
};

interface Expression : Node { };
interface MemberExpression : Expression { // `MemberExpression`, `SuperProperty`
  attribute (Expression or Super) _object; // the object whose property is being accessed
};

interface PropertyName : Node { }; // `[ Expression ]`, `. IdentifierName`

interface ObjectProperty : Node { }; // `PropertyDefinition`
interface NamedObjectProperty : ObjectProperty { // `PropertyName : AssignmentExpression`, `MethodDefinition`
  attribute PropertyName name;
};
interface MethodDefinition : NamedObjectProperty {
  attribute FunctionBody body;
};

interface ImportDeclaration : Node {
  attribute string moduleSpecifier;
};
interface ExportDeclaration : Node { };

interface VariableReference : Node { // `IdentifierReference`, `BindingIdentifier`
  attribute Identifier name;
};

// bindings

typedef (ObjectBinding or ArrayBinding) BindingPattern;
typedef (BindingPattern or BindingIdentifier) Binding;

typedef (AssignmentTargetIdentifier or MemberAssignmentTarget) SimpleAssignmentTarget;
typedef (ObjectAssignmentTarget or ArrayAssignmentTarget) AssignmentTargetPattern;
typedef (AssignmentTargetPattern or SimpleAssignmentTarget) AssignmentTarget; // DestructuringAssignmentTarget

typedef (Binding or BindingWithDefault) Parameter; // `FormalParameter`

interface BindingWithDefault : Node {
  attribute Binding binding;
  attribute Expression init;
};

interface BindingIdentifier : VariableReference { };

interface AssignmentTargetIdentifier : VariableReference { };

interface MemberAssignmentTarget : Node {
  attribute (Expression or Super) _object; // the object whose property is being assigned to
};

interface ComputedMemberAssignmentTarget : MemberAssignmentTarget {
  attribute Expression expression; // the expression resolving to the name of the property to be accessed
};

interface StaticMemberAssignmentTarget : MemberAssignmentTarget {
  attribute IdentifierName property; // the name of the property to be accessed
};

interface ArrayBinding : Node { // `ArrayBindingPattern`
  attribute (Binding or BindingWithDefault)?[] elements; // the elements of the array pattern; a null value represents an elision
  attribute Binding? rest;
};

interface ObjectBinding : Node {
  attribute BindingProperty[] properties;
};

interface BindingProperty : Node { };

interface BindingPropertyIdentifier : BindingProperty { // `SingleNameBinding`
  attribute BindingIdentifier binding;
  attribute Expression? init;
};

interface BindingPropertyProperty : BindingProperty { // `BindingProperty :: PropertyName : BindingElement`
  attribute PropertyName name;
  attribute (Binding or BindingWithDefault) binding;
};

interface AssignmentTargetWithDefault : Node { // the case where the initializer is present in `AssignmentElement :: DestructuringAssignmentTarget Initializer_opt`
  attribute AssignmentTarget binding;
  attribute Expression init;
};

interface ArrayAssignmentTarget : Node { // `ArrayAssignmentPattern`
  attribute (AssignmentTarget or AssignmentTargetWithDefault)?[] elements; // the elements of the array pattern; a null value represents an elision
  attribute AssignmentTarget? rest;
};

interface ObjectAssignmentTarget : Node { // `ObjectAssignmentPattern`
  attribute AssignmentTargetProperty[] properties;
};

interface AssignmentTargetProperty : Node { }; // `AssignmentProperty`

interface AssignmentTargetPropertyIdentifier : AssignmentTargetProperty { // `AssignmentProperty :: IdentifierReference Initializer_opt`
  attribute AssignmentTargetIdentifier binding;
  attribute Expression? init;
};

interface AssignmentTargetPropertyProperty : AssignmentTargetProperty { // `AssignmentProperty :: PropertyName : AssignmentElement_opt`
  attribute PropertyName name;
  attribute (AssignmentTarget or AssignmentTargetWithDefault) binding;
};


// classes

interface Class {
  attribute Expression? super;
  attribute ClassElement[] elements;
};

interface ClassExpression : Expression {
  attribute BindingIdentifier? name;
};
ClassExpression implements Class;

interface ClassDeclaration : Statement {
  attribute BindingIdentifier name;
};
ClassDeclaration implements Class;

interface ClassElement : Node {
  attribute boolean isStatic; // true iff `IsStatic` of ClassElement is true
  attribute MethodDefinition method;
};


// modules

interface Module : Program {
  attribute Directive[] directives;
  attribute (ImportDeclaration or ExportDeclaration or Statement)[] items;
};

interface Import : ImportDeclaration { // an `ImportDeclaration` not including a namespace import
  attribute BindingIdentifier? defaultBinding; // `ImportedDefaultBinding`, if present
  attribute ImportSpecifier[] namedImports;
};

interface ImportNamespace : ImportDeclaration { // an `ImportDeclaration` including a namespace import
  attribute BindingIdentifier? defaultBinding; // `ImportedDefaultBinding`, if present
  attribute BindingIdentifier namespaceBinding;
};

interface ImportSpecifier : Node {
  attribute IdentifierName? name; // the `IdentifierName` in `ImportSpecifier :: IdentifierName as ImportedBinding`; absent if this specifier represents the production `ImportSpecifier :: ImportedBinding`
  attribute BindingIdentifier binding;
};

interface ExportAllFrom : ExportDeclaration { // `export * FromClause;`
  attribute string moduleSpecifier;
};

interface ExportFrom : ExportDeclaration { // `export ExportClause FromClause;`
  attribute ExportFromSpecifier[] namedExports;
  attribute string moduleSpecifier;
};

interface ExportLocals : ExportDeclaration { // `export ExportClause;`
  attribute ExportLocalSpecifier[] namedExports;
};

interface Export : ExportDeclaration { // `export VariableStatement`, `export Declaration`
  attribute (FunctionDeclaration or ClassDeclaration or VariableDeclaration) declaration;
};

interface ExportDefault : ExportDeclaration { // `export default HoistableDeclaration`, `export default ClassDeclaration`, `export default AssignmentExpression`
  attribute (FunctionDeclaration or ClassDeclaration or Expression) body;
};

interface ExportFromSpecifier : Node { // `ExportSpecifier`, as part of an ExportFrom
  attribute IdentifierName name; // the only `IdentifierName in `ExportSpecifier :: IdentifierName`, or the first in `ExportSpecifier :: IdentifierName as IdentifierName`
  attribute IdentifierName? exportedName; // the second `IdentifierName` in `ExportSpecifier :: IdentifierName as IdentifierName`, if present
};

interface ExportLocalSpecifier : Node { // `ExportSpecifier`, as part of an ExportLocals
  attribute IdentifierExpression name; // the only `IdentifierName in `ExportSpecifier :: IdentifierName`, or the first in `ExportSpecifier :: IdentifierName as IdentifierName`
  attribute IdentifierName? exportedName; // the second `IdentifierName` in `ExportSpecifier :: IdentifierName as IdentifierName`, if present
};


// property definition

interface Method : MethodDefinition { // `PropertyName ( UniqueFormalParameters ) { FunctionBody }`, `GeneratorMethod`, `AsyncMethod`
  attribute boolean isAsync; // true for `AsyncMethod`, false otherwise
  attribute boolean isGenerator; // true for `GeneratorMethod`, false otherwise
  attribute FormalParameters params; // the `UniqueFormalParameters`
};

interface Getter : MethodDefinition { }; // `get PropertyName ( ) { FunctionBody }`

interface Setter : MethodDefinition { // `set PropertyName ( PropertySetParameterList ) { FunctionBody }`
  attribute Parameter param; // the `PropertySetParameterList`
};

interface DataProperty : NamedObjectProperty { // PropertyDefinition :: PropertyName : AssignmentExpression`
  attribute Expression expression; // the `AssignmentExpression`
};

interface ShorthandProperty : ObjectProperty { // `PropertyDefinition :: IdentifierReference`
  attribute IdentifierExpression name; // the `IdentifierReference`
};

interface ComputedPropertyName : PropertyName {
  attribute Expression expression;
};

interface StaticPropertyName : PropertyName { // `LiteralPropertyName`
  attribute string value;
};


// literals

interface LiteralBooleanExpression : Expression { // `BooleanLiteral`
  attribute boolean value;
};

interface LiteralInfinityExpression : Expression { }; // a `NumericLiteral` whose MV is >= 2e308

interface LiteralNullExpression : Expression { }; // `NullLiteral`

interface LiteralNumericExpression : Expression { // `NumericLiteral`
  attribute double value;
};

interface LiteralRegExpExpression : Expression { // `RegularExpressionLiteral`
  attribute string pattern;
  attribute boolean global; // whether the `g` flag is present
  attribute boolean ignoreCase; // whether the `i` flag is present
  attribute boolean multiLine; // whether the `m` flag is present
  attribute boolean sticky; // whether the `u` flag is present
  attribute boolean unicode; // whether the `y` flag is present
};

interface LiteralStringExpression : Expression { // `StringLiteral`
  attribute string value;
};


// other expressions

interface ArrayExpression : Expression { // `ArrayLiteral`
  attribute (SpreadElement or Expression)?[] elements; // the elements of the array literal; a null value represents an elision
};

interface ArrowExpression : Expression { // `ArrowFunction`, `AsyncArrowFunction`
  attribute boolean isAsync; // true for `AsyncArrowFunction`, false otherwise
  attribute FormalParameters params;
  attribute (FunctionBody or Expression) body;
};

interface AssignmentExpression : Expression { // `AssignmentExpression :: LeftHandSideExpression = AssignmentExpression`
  attribute AssignmentTarget binding; // the `LeftHandSideExpression`
  attribute Expression expression; // the second `AssignmentExpression`
};

interface BinaryExpression : Expression { // `ExponentiationExpression`, `MultiplicativeExpression`, `AdditiveExpression`, `ShiftExpression`, `RelationalExpression`, `EqualityExpression`, `BitwiseANDExpression`, `BitwiseXORExpression`, `BitwiseORExpression`, `LogicalANDExpression`, `LogicalORExpression`
  attribute BinaryOperator operator;
  attribute Expression left; // the expression before the operator
  attribute Expression right; // the expression after the operator
};

interface CallExpression : Expression {
  attribute (Expression or Super) callee;
  attribute Arguments arguments;
};

interface CompoundAssignmentExpression : Expression { // `AssignmentExpression :: LeftHandSideExpression AssignmentOperator AssignmentExpression`
  attribute CompoundAssignmentOperator operator;
  attribute SimpleAssignmentTarget binding; // the `LeftHandSideExpression`
  attribute Expression expression; // the `AssignmentExpression`
};

interface ComputedMemberExpression : MemberExpression {
  attribute Expression expression; // the expression resolving to the name of the property to be accessed
};

interface ConditionalExpression : Expression { // `ConditionalExpression :: LogicalORExpression ? AssignmentExpression : AssignmentExpression`
  attribute Expression test; // the `LogicalORExpression`
  attribute Expression consequent; // the first `AssignmentExpression`
  attribute Expression alternate; // the second `AssignmentExpression`
};

interface FunctionExpression : Expression {
  attribute BindingIdentifier? name;
};
FunctionExpression implements Function;

interface IdentifierExpression : Expression { }; // `IdentifierReference`
IdentifierExpression implements VariableReference;

interface NewExpression : Expression {
  attribute Expression callee;
  attribute Arguments arguments;
};

interface NewTargetExpression : Expression { };

interface ObjectExpression : Expression {
  attribute ObjectProperty[] properties;
};

interface UnaryExpression : Expression {
  attribute UnaryOperator operator;
  attribute Expression operand;
};

interface StaticMemberExpression : MemberExpression {
  attribute IdentifierName property; // the name of the property to be accessed
};

interface TemplateExpression : Expression { // `TemplateLiteral`, `MemberExpression :: MemberExpression TemplateLiteral`, `CallExpression : CallExpression TemplateLiteral`
  attribute Expression? tag; // The second `MemberExpression` or `CallExpression`, if present.
  attribute (Expression or TemplateElement)[] elements; // The contents of the template. This list must be alternating TemplateElements and Expressions, beginning and ending with TemplateExpression.
};

interface ThisExpression : Expression { }; // `PrimaryExpression :: this`

interface UpdateExpression : Expression { // `UpdateExpression :: LeftHandSideExpression ++`, `UpdateExpression :: LeftHandSideExpression --`, `UpdateExpression :: ++ LeftHandSideExpression`, ``UpdateExpression :: -- LeftHandSideExpression`
  attribute boolean isPrefix; // true for `UpdateExpression :: ++ LeftHandSideExpression` and `UpdateExpression :: -- LeftHandSideExpression`, false otherwise
  attribute UpdateOperator operator;
  attribute SimpleAssignmentTarget operand;
};

interface YieldExpression : Expression { // `YieldExpression :: yield`, `YieldExpression :: yield AssignmentExpression`
  attribute Expression? expression; // The `AssignmentExpression`, if present.
};

interface YieldGeneratorExpression : Expression { // `YieldExpression :: yield * AssignmentExpression`
  attribute Expression expression;
};

interface AwaitExpression : Expression {
  attribute Expression expression;
};


// other statements

interface BlockStatement : Statement {
  attribute Block block;
};

interface BreakStatement : Statement {
  attribute Label? label;
};

interface ContinueStatement : Statement {
  attribute Label? label;
};

interface DebuggerStatement : Statement { };

interface DoWhileStatement : IterationStatement {
  attribute Expression test;
};

interface EmptyStatement : Statement { };

interface ExpressionStatement : Statement {
  attribute Expression expression;
};

interface ForInStatement : IterationStatement { // `for ( LeftHandSideExpression in Expression ) Statement`, `for ( var ForBinding in Expression ) Statement`, `for ( ForDeclaration in Expression ) Statement`, `for ( var BindingIdentifier Initializer in Expression ) Statement`
  attribute (VariableDeclaration or AssignmentTarget) left; // the expression or declaration before `in`
  attribute Expression right; // the expression after `in`
};

interface ForOfStatement : IterationStatement { // `for ( LeftHandSideExpression of Expression ) Statement`, `for ( var ForBinding of Expression ) Statement`, `for ( ForDeclaration of Expression ) Statement`, `for ( var BindingIdentifier Initializer of Expression ) Statement`
  attribute (VariableDeclaration or AssignmentTarget) left; // the expression or declaration before `in`
  attribute Expression right; // the expression after `in`
};

interface ForStatement : IterationStatement { // `for ( Expression ; Expression ; Expression ) Statement`, `for ( var VariableDeclarationlist ; Expression ; Expression ) Statement`
  attribute (VariableDeclaration or Expression)? init; // The expression or declaration before the first `;`, if present.
  attribute Expression? test; // The expression before the second `;`, if present
  attribute Expression? update; // The expression after the second `;`, if present
};

interface IfStatement : Statement { // `if ( Expression ) Statement`, `if ( Expression ) Statement else Statement`, 
  attribute Expression test;
  attribute Statement consequent; // The first `Statement`.
  attribute Statement? alternate; // The second `Statement`, if present.
};

interface LabeledStatement : Statement {
  attribute Label label;
  attribute Statement body;
};

interface ReturnStatement : Statement {
  attribute Expression? expression;
};

interface SwitchStatement : Statement { // A `SwitchStatement` whose `CaseBlock` is `CaseBlock :: { CaseClauses }`.
  attribute Expression discriminant;
  attribute SwitchCase[] cases;
};

interface SwitchStatementWithDefault : Statement { // A `SwitchStatement` whose `CaseBlock` is `CaseBlock :: { CaseClauses DefaultClause CaseClauses }`.
  attribute Expression discriminant;
  attribute SwitchCase[] preDefaultCases; // The `CaseClauses` before the `DefaultClause`.
  attribute SwitchDefault defaultCase; // The `DefaultClause`.
  attribute SwitchCase[] postDefaultCases; // The `CaseClauses` after the `DefaultClause`.
};

interface ThrowStatement : Statement {
  attribute Expression expression;
};

interface TryCatchStatement : Statement { // `TryStatement :: try Block Catch`
  attribute Block body;
  attribute CatchClause catchClause;
};

interface TryFinallyStatement : Statement { // `TryStatement :: try Block Finally`, `TryStatement :: try Block Catch Finally`
  attribute Block body; // The first `Block`.
  attribute CatchClause? catchClause;
  attribute Block finalizer; // The `Finally`.
};

interface VariableDeclarationStatement : Statement {
  attribute VariableDeclaration declaration;
};

interface WhileStatement : IterationStatement {
  attribute Expression test;
};

interface WithStatement : Statement {
  attribute Expression _object;
  attribute Statement body;
};


// other nodes

interface Block : Node {
  attribute Statement[] statements;
};

interface CatchClause : Node { // `Catch`
  attribute Binding binding;
  attribute Block body;
};

interface Directive : Node { // An item in a `DirectivePrologue`
  attribute string rawValue;
};

interface FormalParameters : Node {
  attribute Parameter[] items;
  attribute Binding? rest;
};

interface FunctionBody : Node {
  attribute Directive[] directives;
  attribute Statement[] statements;
};

interface FunctionDeclaration : Statement {
  attribute BindingIdentifier name;
};
FunctionDeclaration implements Function;

interface Script : Program {
  attribute Directive[] directives;
  attribute Statement[] statements;
};

interface SpreadElement : Node {
  attribute Expression expression;
};

interface Super : Node { }; // `super`

interface SwitchCase : Node { // `CaseClause`
  attribute Expression test;
  attribute Statement[] consequent;
};

interface SwitchDefault : Node { // `DefaultClause`
  attribute Statement[] consequent;
};

interface TemplateElement : Node { // `TemplateCharacters`
  attribute string rawValue;
};

interface VariableDeclaration : Node {
  attribute VariableDeclarationKind kind;
  [NonEmpty] attribute VariableDeclarator[] declarators;
};

interface VariableDeclarator : Node {
  attribute Binding binding;
  attribute Expression? init;
};
